ispirazione ricorsiva
int mCostR(int **a, int **t, int *e, int *x, int j, int i) {
int ris;
if (j==0)
return e[i] + a[i][j];
ris = min(
mCostR(a,t,e,x,j-1,i)+a[i][j],
mCostR(a,t e,x,j-1,(i+1)%2)+t[(i+1)%2][j-1]+a[i][j]
);
return ris;
}
int assembly_line(int **a, int **t, int *e, int *x, int j){
return min(
mCostR(a,t, e, x, j, 0) + x[0],
mCostR(a,t, e, x, j, 1) + x[1]
);
}

dinamica bottom-up
tabella f[0…1, 0…n-1] per memorizzare i costi f[i, j] e
identificare il costo minimo
 tabella l[0…1, 0…n] per tenere traccia della catena di
montaggio in cui la stazione j-1 è usata nel percorso a
costo minimo per raggiungere la stazione j
int assembly_lineDP(int **a, int **t, int *e, int *x,
int **f, int **l, int n){
int j, res;
f[0][0] = e[0] + a[0][0];
f[1][0] = e[1] + a[1][0];
for (j=1; j<n; j++) {
if (f[0][j-1]+a[0][j]<=f[1][j-1]+t[1][j-1]+a[0][j]){
f[0][j]=f[0][j-1]+a[0][j];
l[0][j]=0;
}
else {
f[0][j]=f[1][j-1]+t[1][j-1]+a[0][j];
l[0][j]=1;
}
if (f[1][j-1]+a[1][j]<=f[0][j-1]+t[0][j-1]+a[1][j]) {
f[1][j]=f[1][j-1]+a[1][j];
l[1][j]=1;
}
else {
f[1][j]=f[0][j-1]+t[0][j-1]+a[1][j];
l[1][j]=0;
}
}
if (f[0][n-1] + x[0] <= f[1][n-1] + x[1]) {
res = f[0][n-1] + x[0];
l[0][n] = 0; l[1][n] = 0;
}
else {
res = f[1][n-1] + x[1];
l[1][n] = 1; l[0][n] = 1;
}
return res;
}

Costruzione soluzione ottima
tabella l -> percorso delle 
catene usate/scelte per uscire dalla
stazione finale
la ripercorro da dx verso sx
per mostrare la soluzione finale 
usata come migliore
void displaySol(int **l, int i, int n) {
if (n==0)
return;
displaySol(l, l[i][n-1], n-1);
printf("line %d station %d\n", i, n-1);
}

T(n) = (n)
rispetto al costo esponenziale nel tempo della soluzione ricorsiva.
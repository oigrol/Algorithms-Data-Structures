typedef struct node_s *link;
typedef struct node_s {
 item item;
 link l;
 link r;
} node_t;

{in BST.h
typedef struct binarysearchtree_s *BST; }

typedef struct binarysearchtree_s {
 link root;
 link z; 
} binarysearchtree_t;


XXX calcolo di parametri

-conta numero nodi
int count(link root) {
 if (root == NULL) return 0;
 return count(root->left) + count(root->right) +1;
}
oppure
void count(link root, int *cnt) {
 if (root == NULL) return;
 (*cnt)++;
 count(root->l, cnt);
 count(root->r, cnt);

-conta altezza
//La funzione visita ogni nodo una volta e ritorna il massimo tra le altezze dei suoi sottoalberi + 1.
//Funziona in O(n), dove n è il numero di nodi.

int height(link root) {
 int u, v;
 if (root==NULL) return -1;
 u = height(root->left);
 v = height(root->right);
 if (u>v) 
  return u+1;
 return v+1;
}

XXX visita BST
void preOrder(link root) {
 if (root==NULL) return;
 printf("%s ", root->name);
 preOrder(root->l);
 preOrder(root->r);
}

void inOrder(link root) {
 if (root==NULL) return;
 inOrder(root->l);
 printf("%s ", root->name);
 inOrder(root->r);
}

void postOrder(link root) {
 if (root==NULL) return;
 postOrder(root->l);
 postOrder(root->r);
 printf("%s ", root->name);
}


link newNode(item item, link l, link r) {
 link x=malloc(sizeof(*x));
 x->item = item;
 x->l = l;
 x->r = r;
 return x;
}


int BSTcount(BST bst) {
 return countR(bst->h, bst->z);
}
int countR(link h, link z) {
 if (h==z) return 0;
 return countR(h->l, z) + countR(h->r, z) + 1;
}

XXX Ricerca
item BSTsearch(BST bst, key k) {
 searchR(bst->h, k, bst->z);
}
item searchR(link h, key k, link z) {
 int cmp = KEYcmp(k, KEYget(h->item));
 if (cmp == 0) return h->item;
 if (cmp == -1) searchR(h->l, k, z);
 if (cmp == 1) searchR(h->r, k, z);
}

XXX minimo
item minR(link h, link z) {
 if (h == z) return ItemNULL();
 if (h->l == z) return h->item; //è il minimo
 return minR(h->l, z);
}

massimo
item maxR(link h, link z) {
 if (h == z) return ItemNULL();
 if (h->r == z) return h->item; //è il massimo
 return maxR(h->r, z);
}

XXX Insert Ricorsivo in foglia
void BSTinsert_leafR(BST bst, Item x) {
 bst->root = insertR(bst->root, x, bst->z);
}
link insertR(link h, Item x, link z) {
 if (h==z) return newNode(x, z, z);
 int cmp = KEYcmp(Keyget(x), KEyget(h->item));
 if (cmp == -1) h->l = insertR(h->l, x, z);
 else h->r = insertR(h->r, x, z);
 return h;
}


XXX rotazione a dx
link rotR(link h) {
 link x = h->l;
 h->l = x->r;
 x->r = h;
 return x;
}

rotazione a sx
link rotL(link h) {
 link x = h->r;
 h->r = x->l;
 x->l = h;
 return x;
}

XXX BSTinsert (in radice)
fai insert corretto e poi fai risalire con rotazioni
link insertR(link h, Item x, link z) {
 if (h==z) return newNode(x, z, z);
 int cmp = KEYcmp(Keyget(x), KEyget(h->item));
 if (cmp == -1) {
  h->l = insertR(h->l, x, z);
  h = rotR(h);
 else [
  h->r = insertR(h->r, x, z);
  h = rotL(h);
 return h;
}

--------------------------------------------------------------------------------------

XXX se ha anche puntatore al padre e numero nodi sottostanti
typedef strcut BSTnode_s {
 item item;
 link p;
 link l;
 link r;
 int N;
} BSTnode_t;


link newNode(item item, link p, link l, link r, int N) {
 link x=malloc(sizeof(*x));
 x->item = item;
 x->p = p;
 x->l = l;
 x->r = r;
 x->N = N;
 return x;
}

XXX conta nodi 
int BSTcount(BST bst) {
 return countR(bst->h, bst->z);
}
int countR(link h, link z) {
 if (h==z) return 0;
 return countR(h->l, z) + countR(h->r, z) + 1;
}

item BSTsearch(BST bst, key k) {
 searchR(bst->h, k, bst->z);
}
item searchR(link h, key k, link z) {
 int cmp = KEYcmp(k, KEYget(h->item));
 if (cmp == 0) return h->item;
 if (cmp == -1) searchR(h->l, k, z);
 if (cmp == 1) searchR(h->r, k, z);
}

XXX minimo
item minR(link h, link z) {
 if (h == z) return ItemNULL();
 if (h->l == z) return h->item; //è il minimo
 return minR(h->l, z);
}

massimo
item maxR(link h, link z) {
 if (h == z) return ItemNULL();
 if (h->r == z) return h->item; //è il massimo
 return maxR(h->r, z);
}

XXX Insert Ricorsivo in foglia
void BSTinsert_leafR(BST bst, Item x) {
 bst->root = insertR(bst->root, x, bst->z);
}
link insertR(link h, Item x, link z) {
 if (h==z) return newNode(x, z, z, z, 1);
 int cmp = KEYcmp(Keyget(x), KEyget(h->item));
 if (cmp == -1) h->l = insertR(h->l, x, z); h->l->p = h;
 else h->r = insertR(h->r, x, z); h->r->p = h;
 (h->N)++;
 return h;
}

XXX rotazione a dx
link rotR(link h) {
 link x = h->l;
 h->l = x->r;
 x->r->p = h;
 x->r = h;
 x->p = h->p;
 h->p = x;
 x->N = h->N;
 h->N = 1;
 h->N += (h->l) ? h->l->N : 0;
 h->N += (h->r) ? h->r->N : 0;
 return x;
}

rotazione a sx
link rotL(link h) {
 link x = h->r;
 h->r = x->l;
 x->l->p = h;
 x->l = h;
 x->p = h->p;
 h->p = x;
 x->N = h->N;
 h->N = 1;
 h->N += (h->l) ? h->l->N : 0;
 h->N += (h->r) ? h->r->N : 0;
 return x;
}

XXX BSTinsert (in radice)
fai insert corretto e poi fai risalire con rotazioni
link insertR(link h, Item x, link z) {
 if (h==z) return newNode(x, z, z, z, 1);
 int cmp = KEYcmp(Keyget(x), KEyget(h->item));
 if (cmp == -1) {
  h->l = insertR(h->l, x, z);
  h = rotR(h); //già aggiorna tutti i numeri di nodi
  h->N++;
 else [
  h->r = insertR(h->r, x, z);
  h = rotL(h);
  h->N++;
 return h;
}

XXX select rango
selectR(link h, int r, link z) {
 //rango = r
 int t;
 if (h == z) return ItemNULL();
 t = h->l->N;
 if (t > r) 
  selectR(h->l, r, z);
 if (t < r) 
  selectR(h->r, r-t-1, z);
 return h->item; //è il nodo di rango r cercato
}
Item BSTselect(BST bst, int r) {
return selectR(bst->root, r, bst->z);
}

XXX partizionamento (fa risalire nodo di rango r)
link partR(link h, int r) {
 int t = h->l->N;
 if (t > r) {
  h->l = partR(h->l, r);
  h = rotR(h);
 }
 if (t < r) {
  h->r = partR(h->r, r-t-1);
  h = rotL(h);
 }
 return h;
}

XXX cancellazione di una foglia es: 15 basta toglierla
trovo il successore di 11 che è il minimo dell'albero sx (12) e lo faccio risalire con la partition rispetto a rango 0 (rotazioni a dx e sx)
ricostruzione dell’albero con radice 12

link joinLR(link a, link b, link z) {// fa la partition rispetto al nodo con rango 0, ovvero il successore del nodo eliminato nonché il minimo del sottoalbero dx
 if (b==z) return a;
 b = partR(b,0);
 b->l = a;
 a->p = b;
 b->N = a->N + b->r->N + 1;
 return b;
}
link deleteR(link h, key k, link z) {
 link y, p;
 if (h==z) return z;
 int cmp = KEYcmp(k, KEYget(h->item));
 if (cmp == -1) h->l = deleteR(h->l, k, z);
 if (cmp == 1) h->r = deleteR(h->r, k, z);
 h->N--;
 if (cmp == 0) {
  y = h;
  p = h->p;
  h = joinLR(h->l, h->r, z); //cancello nodo corrente h
  h->p = p;
  free(y);
 }
 return h;
}
void BSTdelete(BST bst, Key k) {
 bst->root= deleteR(bst->root, k, bst->z);
}

XXX bilanciamento
static link balanceR(link h, link z) {
 int r;
 if (h == z)
  return z;
 r = (h->N+1)/2-1; //è una partition rispetto alla chiave mediana
 h = partR(h, r);
 h->l = balanceR(h->l, z);
 h->r = balanceR(h->r, z);
 return h;
}
void BSTbalance(BST bst) {
 bst->root = balanceR(bst->root, bst->z);
}

XXX successore
Item searchSucc(link h, Key k, link z) {
link p;
if (h == z) return ITEMsetNull();
if (KEYcmp(k, KEYget(h->item))==0) {
 if (h->r != z) return minR(h->r, z);
 else {
  p = h->p;
  while (p != z && h == p->r) {
   h = p; 
   p = p->p;
  }
  return p->item;
 }
}
if (KEYcmp(k, KEYget(h->item))==-1)
 return searchSucc(h->l, k, z);
return searchSucc(h->r, k, z);
}
Item BSTsucc(BST bst, Key k) {
return searchSucc(bst->root, k, bst->z);
}

XXX predecessore
Item searchPred(link h, Key k, link z) {
link p;
if (h == z) return ITEMsetNull();
 if (KEYcmp(k, KEYget(h->item))==0) {
  if (h->l != z) return maxR(h->l, z);
  else {
   p = h->p;
   while (p != z && h == p->l) {
    h = p; 
    p = p->p;
   }  
   return p->item;
 }
}
if (KEYcmp(k, KEYget(h->item))==-1)
 return searchPred(h->l, k, z);
return searchPred(h->r, k, z);
}
Item BSTpred(BST bst, Key k) {
return searchPred(bst->root, k, bst->z);
}


-------------------------------------------------------------------------------------
bst.h
typedef struct  binarysearchtree *BST;
BST   BSTinit() ;
void  BSTfree(BST bst); 
int   BSTcount(BST bst); 
int   BSTempty(BST bst);
Item  BSTsearch(BST bst, Key k);
void  BSTinsert_leafI(BST bst, Item x); 
void  BSTinsert_leafR(BST bst, Item x); 
void  BSTinsert_root(BST bst, Item x); 
Item  BSTmin(BST bst);
Item  BSTmax(BST bst);
void  BSTvisit(BST bst, int strategy);
SE punt padre e num nodi sottoalbero
void BSTdelete(BST bst, Key k);
Item BSTselect(BST bst, int r);
Item BSTsucc(BST bst, Key k);
Item BSTpred(BST bst, Key k);
void BSTbalance(BST bst);

bst.c
#include "Item.h" 
#include "BST.h"
typedef struct BSTnode* link;
struct BSTnode { Item item; link l; link  r;} ;
struct binarysearchtree { link root; link z; };
static link NEW(Item item, link l, link r) { 
link x = malloc(sizeof *x);
x->item = item; 
x->l = l; 
x->r = r; 
return x;
}

BST BSTinit( ) {
BST bst = malloc(sizeof *bst) ;
bst->root= ( 
bst->z = NEW(ITEMsetNull(), NULL, NULL));
return bst;
}

void BSTfree(BST bst) {
if (bst == NULL)
 return;
treeFree(bst->root, bst->z); 
free(bst->z);
free(bst);
}
static void treeFree(link h, link z) { 
if (h == z)
 return; 
treeFree(h->l, z); 
treeFree(h->r, z); 
free(h);
}

static int countR(link h, link z) {
if (h == z) return 0;
return countR(h->l, z) + countR(h->r, z) +1;
}
int BSTcount(BST bst) {
return countR(bst->root, bst->z);
}

int BSTempty(BST bst) { 
if (BSTcount(bst) == 0)
 return 1;
return 0;
}

insert in foglia iterativo
void BSTinsert_leafI(BST bst, Item x) {
link p = bst->root, h = p; 
if (bst->root == bst->z) {
bst->root = NEW(x, bst->z, bst->z);
return;
}
while (h != bst->z) { 
p = h; //h->N++; se 2 versione
h=(KEYcmp(KEYget(x),KEYget(h->item))==-1) ? h->l : h->r;
}
h = NEW(x, bst->z, bst->z); //NEW(x, p, bst->z, bst->z, 1); se 2 vers
if (KEYcmp(KEYget(x), KEYget(p->item))==-1) 
p->l = h;
else
p->r = h;
}

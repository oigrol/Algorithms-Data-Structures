Set.h
typedef struct set *SET;

SET SETinit(int maxN);
void SETfree(SET s);
void SETfill(SET s, Item val); 
int  SETsearch(SET s, Key k); 
SET  SETunion(SET s1, SET s2);
SET  SETintersection(SET s1, SET s2); 
int  SETsize(SET s);
int  SETempty(SET s);
void SETdisplay(SET s);

Implementazioni possibili
â–ª vettore
o non ordinato
o ordinato
â–ª lista
o non ordinata
o Ordinata
â–ª Perche NON si adotta una soluzione stile union-find (vettore con accesso diretto e  corrispondenza dato-indice)?
o Nella union-find un elemento appartiene a UN SOLO INSIEME
o Il caso generale Ã¨ diverso. Un elemento puÃ² appartenere a piÃ¹ insiemi, che supportano operazioni di unione, intersezione, differenza, ecc.

â–¡    complessitÃ  della funzione SETsearch di appartenenza:
o vettore ordinato â‡’ ricerca dicotomica  â‡’ O(logN)
o vettore non ordinato â‡’ ricerca lineare  â‡’ O(N)
o lista (ordinata/non ordinata)  â‡’ ricerca lineare  â‡’ O(N)
â–¡    complessitÃ  delle funzioni SETunion e SETintersection:
o vettore/lista ordinato â‡’ O(N)
o vettore/lista non ordinato â‡’ O(NÂ²)

SETintersection (Scelta libera di implementazione)
1.	Vettori ordinati â†’ Merge-like scan (2 puntatori):
o	Si scorrono entrambi gli array con due puntatori e si raccolgono gli elementi comuni.
o	ComplessitÃ : O(N+M)O(N+M)O(N+M).
void setIntersectionSorted(int A[], int sizeA, int B[], int sizeB) {
    int i = 0, j = 0;

    while (i < sizeA && j < sizeB) {
        if (A[i] == B[j]) {
            printf("%d ", A[i]);
            i++;
            j++;
        } else if (A[i] < B[j]) {
            i++;
        } else {
            j++;
        }
    }
}
2.	Vettori non ordinati â†’ Uso di un HashSet:
o	Inserire il primo insieme in una hash table, poi verificare gli elementi del secondo insieme.
o	ComplessitÃ : O(N+M)O(N + M)O(N+M) in media.
#define TABLE_SIZE 100

int hashTable[TABLE_SIZE] = {0};  // Hashtable 

void setIntersectionHash(int A[], int sizeA, int B[], int sizeB) {
    for (int i = 0; i < sizeA; i++)
        hashTable[A[i] % TABLE_SIZE] = 1;

    for (int j = 0; j < sizeB; j++) {
        if (hashTable[B[j] % TABLE_SIZE]) {
            printf("%d ", B[j]);
        }
    }
}
3.	Liste concatenate:
o	Se ordinate â†’ stesso metodo dei vettori ordinati O(N+M)O(N+M)O(N+M).
o	Se non ordinate â†’ usa hash table O(N+M)O(N+M)O(N+M) in media o sorting + scan O(Nlogâ¡N+Mlogâ¡M)O(N \log N + M \log M)O(NlogN+MlogM).
typedef struct Node *link;
typedef struct Node {
    int value;
    link next;
} Node;

void setIntersectionList(link A, link B) {
    while (A && B) {
        if (A->value == B->value) {
            printf("%d ", A->value);
            A = A->next;
            B = B->next;
        } else if (A->value < B->value) {
            A = A->next;
        } else {
            B = B->next;
        }
    }
}
ðŸ“Œ Quale scegliere?
â€¢	Se gli insiemi sono giÃ  ordinati â†’ Metodo con due puntatori.
â€¢	Se gli insiemi sono piccoli â†’ Lista non ordinata con scansione O(NM)O(NM)O(NM).
â€¢	Se gli insiemi sono grandi e non ordinati â†’ Hash table.



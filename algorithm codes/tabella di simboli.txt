st.h
typedef struct symboltable *ST;
ST   STinit(int maxN); 
void STfree(ST st); 
int  STcount(ST st);
void STinsert(ST st, Item val); 
Item STsearch(ST st, Key k);
void STdelete(ST st, Key k); 
Item STselect(ST st, int r); 
void STdisplay(ST st ;

versioni
 tabelle ad accesso diretto
 strutture lineari (vettore/lista ordinato/non ordinato)
 strutture ad albero
 alberi binari di ricerca (BST) e loro varianti
 tabelle di hash

st.c
struct symbtab {Item *a; int N; int M;};
ST STinit(int maxN) {
ST st; int i;
st = malloc(sizeof(*st));
st->a = malloc(maxN * sizeof(Item) );
for (i = 0; i < maxN; i++)
st->a[i] = ITEMsetvoid(); 
st->M = maxN;
st->N= 0;
return st;
}
int STcount(ST st) { 
return st->N;
}
void STfree(ST st) {
free(st->a);
free(st);
}
void STinsert(ST st, Item val) {  
int index = GETindex(KEYget(val)); 
st->a[index] = val;
st->N++;
}
Item STsearch(ST st, Key k) { 
int index = GETindex(k); 
return st->a[index];
}
void STdelete(ST st, Key k) {
st->a[GETindex(k)] = ITEMsetvoid();
st->N--;
}
Item STselect(ST st, int r) { 
int i;
for (i = 0; i < st->M; i++)
if ((ITEMcheckvoid(st->a[i])==0) && (r-- == 0))
return st->a[i]; 
return NULL;
}
void STdisplay(ST st){ int i;
for (i = 0; i < st->M; i++)
if (ITEMcheckvoid(st->a[i])==0) 
ITEMstore(st->a[i]);
}

Gestione dei duplicati nelle tabelle di simboli
Casistica:
In inserzione:
▪    “si ignora il nuovo elemento” : si prosegue come se l’istanza (di
inserimento) non sia stata avanzata = si ignora l’inserimento
▪    “si dimentica il vecchio elemento” : si cancella (o sovrascrive)
l’elemento già presente, poi si  procede al nuovo inserimento


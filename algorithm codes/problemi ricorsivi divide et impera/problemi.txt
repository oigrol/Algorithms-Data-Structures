FORMA ITERATIVA FATTORIALE
unsigned long fact(int n) {
unsigned long tot = 1;
int i;
for (i=2; i<=n; i++)
tot = tot * i;
return tot;
}

- FAttoriale NON tail-recursive
unsigned long fact(int n) {
if ((n == 0) || (n == 1))
return 1;
return n*fact(n-1);
}
- DA NON TAIL-RECURSIVE A ITERATIVO CON STACK GESTITO DALL'UTENTE
unsigned long fact (int n){
unsigned long f = 1;
S stack; //ADT S(stack)
stack = STACKinit(N);
while (n>0) {
STACKpush(stack, n);
n--;
}
while (STACKsize(stack) > 0) {
n = STACKpop(stack);
f = n * f;
}
return f;
}

- FORMA TAIL-RECURSIVE FATTORIALE
unsigned long tr_fact(int n, unsigned long f) {
if(n == 0)
return f;
return tr_fact(n-1, n*f);
}
- DA TAIL-RECURSIVE A ITERATVA
unsigned long tr2iterfact(int n, unsigned long f){
while (n > 0) {
f = n * f;
n--;
}
return f;
}

Fibonacci
unsigned long fib(int n){
if(n == 0 || n == 1)
return(n);
return(fib(n-2) + fib(n-1));
}

FORMA ITERATIVA FIBONACCI
unsigned long fib(int n) {
 unsigned long fib1=1, fib0=0, f;
 int i;
 if(n == 0 || n == 1)
  return n;
 f = fib1 + fib0; /* n==2 */
 for(i=3; i<= n; i++) {
  fib0 = fib1;
  fib1 = f; //fib1+fib0
 f = fib1+fib0; //2
 }
 return f;
}

MASSIMO COMUNE DIVISORE
Versione 1 - Euclide
int gcd(int x, int y) {
if(x == y)
return x;
if (x > y)
return gcd(x-y, y);
return gcd(x, y-x);
}

Versione 2 - Euclide-Lame-Dijkstra
int gcd(int x, int y) {
if(y == 0)
return x;
return gcd(y, x % y);
}

Prodotto tra due interi
long prod(int *x,int lx,int rx,int *y,int ly,int ry,int n) {
long t1, t2, t3;
if (n == 1)
return (x[lx]*y[ly]);
t1 = prod(x, lx, (lx+rx)/2, y, ly, (ly+ry)/2, n/2);
t2 = prod(x, lx, (lx+rx)/2, y, ly+n/2, ry, n/2)
+ prod(x, lx+n/2, rx, y, ly, (ly+ry)/2, n/2);
t3 = prod(x, lx+n/2, rx, y, ly + n/2, ry, n/2);
return t1 * pow(10,n) + t2 * pow (10, n/2) + t3;
}

Ricerca binaria
int BinSearch(int v[], int l, int r, int k) {
int m;
if (l > r)
return -1;
m = (l + r)/2;
if (k == v[m])
return (m);
if (k < v[m])
return BinSearch(v, l, m-1, k);
return BinSearch(v, m+1, r, k);
}

FORMA ITERATIVA RICERCA BINARIA
int BinSearch(int v[], int N, int k) {
int m, found= 0, l=0, r=N-1;
while(l <= r && found == 0){
m = (l+r)/2;
if(v[m] == k)
found = 1;
if(v[m] < k)
l = m+1;
else
r = m-1;
}
if (found == 0)
return -1;
return m;
}

STAMPA reverse 
void reverse_print(char *s) {
if(*s != '\0') {
reverse_print(s+1);
putchar(*s);
}
return;
}

X Le Torri di Hanoi
 Problema iniziale: spostare n dischi da 0 a 2
 Riduzione a sottoproblemi:
 n-1 dischi da 0 a 1, 2 deposito
 l’ultimo disco da 0 a 2
 n-1 dischi da 1 a 2, 0 deposito
 Condizione di terminazione: si muove 1 solo disco.
Problema 000 222 decomposto in 3 sottoproblemi di cui 1
elementare:
1. dischi medio e piccolo da 0 a 1 -> 000 011
2. disco grande da 0 a 2 -> 011 211
3. dischi medio e piccolo da 1 a 2. 211 222

void Hanoi(int n, int src, int dest) {
int aux;
aux = 3 - (src + dest);
if (n == 1) {
printf("src %d -> dest %d \n", src,dest);
return;
}
Hanoi(n-1, src, aux);
printf("src %d -> dest %d \n", src, dest);
Hanoi(n-1, aux, dest);
}

 Il righello.
Tracciare una tacca in ogni punto tra 0 e 2n estremi esclusi, dove:
 la tacca centrale è alta n unità,
 le due tacche al centro delle due metà di destra e sinistra
sono alte n-1
 etc.
 mark(x, h) traccia una tacca alta h unità in posizione x
void mark(int m, int h) {
int i;
printf("%d \t", m);
for (i = 0; i < h; i++)
printf("*");
printf("\n");
}

void ruler(int l, int r, int h) {
int m;
m = (l + r)/2;
if (h > 0) {
ruler(l, m, h-1);
mark(m, h);
ruler(m, r, h-1);
}
}
